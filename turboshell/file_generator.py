import os
from datetime import datetime
from .utils import write_to_file, ensure_dir_exists, extract_stubs


class FileGenerator:
    """
    A class for generating the command and alias files.
    """

    def __init__(self, conf_dir):
        self.conf_dir = conf_dir
        self.venv_dir = os.environ.get('VIRTUAL_ENV')
        self.generated_files_dir = os.path.join(self.conf_dir, 'generated')
        self.script_file = os.path.join(self.generated_files_dir, 'turboshell')
        self.definitions_file = os.path.join(self.generated_files_dir, 'definitions')
        self.lines = []
        self.unique_alises = set()

    def generate_alias_file(self, aliases, functions, info_entries):
        ensure_dir_exists(self.generated_files_dir)
        start = datetime.now()
        self._build_alias_file(aliases, functions, info_entries)
        end = datetime.now()
        time = (end - start).microseconds / 1000
        print("Generated {} aliases in {} ms".format(len(aliases), time))

    def generate_turboshell_script(self):
        """
        Builds the excutable script "turboshell"
        """
        ensure_dir_exists(self.generated_files_dir)
        import stat
        write_to_file(self.script_file, [
            'source {}/bin/activate'.format(self.venv_dir),
            'TURBOSHELL_USER_DIR={} python -m turboshell $*'.format(self.conf_dir)
        ])
        st = os.stat(self.script_file)
        os.chmod(self.script_file, st.st_mode | stat.S_IEXEC)

    @property
    def turboshell_alias_line(self):
        return "alias turboshell='bash {}'".format(self.script_file)

    def _build_alias_file(self, aliases, functions, info_entries):
        self._add_headers()
        self._add_builtins()
        self._add_custom_aliases(aliases)
        self._add_custom_functions(functions)
        self._add_info_function(info_entries)
        self._add_stubs()
        write_to_file(self.definitions_file, self.lines)

    def _add_headers(self):
        """
        Add the initial lines for the alias file.
        """
        add = self.lines.append
        add("# This file is generated by turboshell.")
        add("# Changes made here will be overwritten.")
        add(" ")

    def _add_builtins(self):
        """
        Add aliases for built in commands.
        """
        add = self.lines.append
        add("# Built-in aliases:")
        add(" ")
        add(self.turboshell_alias_line)
        add("alias ts.activate-venv='source {}/bin/activate'".format(self.venv_dir))
        add("alias ts.rebuild='turboshell rebuild && source {}'".format(self.definitions_file))
        add("alias ts.reload='source {}'".format(self.definitions_file))
        add(" ")

    def _add_custom_aliases(self, aliases):
        add = self.lines.append
        add("# Your aliases:")
        add(" ")
        for name, cmd in aliases.items():
            self.unique_alises.add(name)
            add("alias {}='{}'".format(name, cmd))
        add(" ")

    def _add_custom_functions(self, functions):
        add = self.lines.append
        add("# Your functions:")
        add(" ")
        for name, body in functions.items():
            self.unique_alises.add(name)
            add("function " + name + " {")
            for line in body:
                add("  " + line)
            add("}")
        add(" ")

    def _add_stubs(self):
        """
        Creates stubs for all intermediate aliases, e.g.

        if we have aliases:

            p.show
            p.new

        This will create a stub for 'p.' as:
    
            alias p.=ts.stub
        """
        add = self.lines.append
        stubs = set()
        for alias in self.unique_alises:
            for stub in extract_stubs(alias):
                if stub not in self.unique_alises:
                    stubs.add(stub)
        if len(stubs):
            add("# Stubs:")
            add(" ")
            add("alias ts.stub='echo stub'".format(stub))
            for stub in stubs:
                add("alias {}=ts.stub".format(stub))
            add(" ")

    def _add_info_function(self, info_entries):
        """
        Creates the ts.info bash function.
        """
        add = self.lines.append

        def echo(line):
            add(" echo '  {}'".format(line))

        def add_group(items):
            """items must be list of tuples"""
            if len(items) == 0:
                return
            for cmd, info in sorted(items, key=lambda x: x[0]):
                space = (longest - len(cmd)) * ' '
                echo("{} {}| {}".format(cmd, space, info))
            echo('')

        def find_entries(predicate):
            """returns list of tuples for entries whose key matches predicate"""
            return [(k, v) for k, v in info_entries.items() if predicate(k)]

        # Add the entries for built in functions
        self._add_builtins_info(info_entries)

        # Get longest cmd text so we know how much to pad everything by
        longest = max(len(e) for e in info_entries.keys())

        add("# Info function:")
        add('')
        add("function ts.info {")
        echo('')
        echo('Alias file:  {}'.format(self.definitions_file))
        echo('Rebuilt on:  {}'.format(datetime.today().strftime('%Y-%m-%d %H:%M:%S')))
        echo('')
        echo('Commands:')
        echo('')

        # Write entries for built in commands first
        builtin_entries = find_entries(lambda cmd: cmd.startswith('ts.'))
        add_group(builtin_entries)

        # Then for ungrouped entries
        ungrouped_entries = find_entries(lambda cmd: '.' not in cmd)
        add_group(ungrouped_entries)

        # Then for groups
        group_prefixes = set(k.split('.')[0] for k in info_entries if '.' in k and not k.startswith('ts.'))
        for prefix in group_prefixes:
            group = find_entries(lambda cmd: cmd.startswith(prefix))
            add_group(group)

        add("}")

    def _add_builtins_info(self, info_entries):
        info_entries['ts.info'] = 'Shows info on commands'
        info_entries['ts.activate-venv'] = 'Activates the virtual environment'
        info_entries['ts.reload'] = 'Reloads the aliases in current shell'
        info_entries['ts.rebuild'] = 'Rebuilds and reloads the aliases in current shell'
