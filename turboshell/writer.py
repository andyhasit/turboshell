from datetime import datetime
from .loaders import load_builtin_cmds
from .utils import extract_stubs, write_to_file


class Writer:
    """
    Writes to a definitions file.
    """
    def __init__(self, ts, target):
        self.ts = ts
        self.settings = ts.settings
        self.now = datetime.today().strftime('%Y-%m-%d %H:%M:%S')
        self.target = target
        self.unique_names = set()
        self.lines = []
        self.report_lines = []

    def write(self):
        start = datetime.now()
        self._build_file()
        end = datetime.now()
        time = (end - start).microseconds / 1000
        print(f"Generated file: {self.target}")
        print(f"Time: {time} ms")
        for line in self.report_lines:
            print(line)
    
    def line(self, line):
        self.lines.append(line)

    def report(self, number, type):
        self.report_lines.append(f"{number} {type}")

    def _build_file(self):
        if self.settings.include_header:
            self._add_header()
            
        self._add_entries("variables", self.ts.vars, self._add_vars)

        if self.settings.include_builtins:
            load_builtin_cmds()
            if not self.settings.handle_not_found:
                self.ts.functions.pop("command_not_found_handle")

        self._add_entries("aliases", self.ts.aliases, self._add_aliases)
        self._add_entries("functions", self.ts.functions, self._add_functions)

        if self.settings.add_info:
            self._add_info_function(self.ts.info_entries, self.ts.alias_groups, self.ts.group_info)
        if self.settings.add_stubs:
            self._add_stubs()
        write_to_file(self.target, self.lines)
        
    def _add_header(self):
        self.line(f"# This file was generated by Turboshell's rebuild command on {self.now}.")
        self.line("# Changes made here will be overwritten.")
        self.line(" ")

    def _add_entries(self, name, items, function):
        if len(items):
            function(items)
            self.line(" ")
            self.report(len(items), name)

    def _add_vars(self, vars):
        for name in sorted(vars):
            value = vars[name]
            self.line(f"{name}={value}")

    def _add_aliases(self, aliases):
        for name in sorted(aliases):
            cmd = aliases[name]
            self.unique_names.add(name)
            self.line(f"alias {name}='{cmd}'")
           
    def _add_functions(self, functions):
        for name in sorted(functions):
            lines = functions[name]
            self.unique_names.add(name)
            self._build_file_function(name, *lines)

    def _build_file_function(self, name, *lines):
        self.line("function " + name + " {")
        for line in lines:
            self.line("  " + line)
        self.line("}")

    def _add_stubs(self):
        """
        Creates stubs for all intermediate aliases to improve autocompletion.
        Experimental, may not be useful.
        """
        stubs = set()
        for alias in self.unique_names:
            for stub in extract_stubs(alias):
                if stub not in self.unique_names:
                    stubs.add(stub)
        if len(stubs):
            self.line("# Stubs:")
            self.line(" ")
            self.line("alias ts.stub='echo stub'")
            for stub in stubs:
                self.line(f"alias {stub}=ts.stub")
                # add(f"complete -F _longopt -o nospace {stub}")
            self.line(" ")

    def _add_info_function(self, info_entries, alias_groups, group_info):
        """
        Creates the ts.info bash function.
        """

        def echo(line):
            """Adds a bash echo call"""
            self.line(f" echo '  {line}'")

        def add_group(items):
            """items must be list of tuples"""
            if len(items) == 0:
                return
            for alias, info in sorted(items, key=lambda x: x[0]):
                space = (longest - len(alias)) * ' '
                echo(f"{alias} {space}| {info}")
            echo('')

        def find_entries(predicate):
            """returns list of tuples for entries whose key matches predicate"""
            return [(k, v) for k, v in info_entries.items() if predicate(k)]

        # Get longest alias text so we know how much to pad everything by
        if len(info_entries):
            longest = max(len(e) for e in info_entries.keys())
        else:
            longest = 4

        self.line("function ts.info {")
        echo('')
        echo(f'File path:  {self.target}')
        echo(f'Last build:  {self.now}')
        echo('')
        echo('Commands:')
        echo('')

        # Write entries for built in commands first
        builtin_entries = find_entries(lambda alias: alias.startswith('ts.'))
        add_group(builtin_entries)

        # Then for ungrouped entries
        ungrouped_entries = find_entries(lambda alias: alias not in alias_groups and not alias.startswith('ts.'))
        add_group(ungrouped_entries)

        # Then for grouped_entries
        group_names = set(alias_groups.values())
        for group in sorted(group_names):
            echo('')
            echo(f'{group}')
            echo('-' * len(group))
            if group in group_info:
                for line in group_info[group]:
                    echo(line)
            echo('')
            group = find_entries(lambda alias: alias in alias_groups and alias_groups[alias] == group)
            add_group(group)

        self.line("}")
